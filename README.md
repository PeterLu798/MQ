# MQ

* [1. 为什么需要消息队列](#1)
* [2. 该如何选择消息队列](#2)
* [3. 主题和队列有什么区别](#3)
* [4. 利用事务消息实现分布式事务](#4)
5. 如何确保消息不会丢失
6. 如何防止重复消费
7. 消息积压如何解决
8. 如何保证消息的严格顺序
9. 如何使用异步设计提升系统性能
10. 实现高性能网络I/O的常用框架
11. 消息队列中的高性能序列化和反序列化
12. 消息队列中的高性能传输协议
13. 内存管理：如何避免内存溢出和频繁GC
14. kafka如何实现高性能I/O
15. 如何使用缓存来减少磁盘I/O
16. Java中的锁以及如何选择适用于自己的锁
17. 数据压缩：时间换空间的游戏
18. 源码分析：RocketMQ是如何发消息的
19. 源码分析：RocketMQ是如何消费消息的
20. 源码分析：Kafka是如何消费消息的
21. RocketMQ和Kafka消息复制实现的差异点在哪
22. RocketMQ客户端如何在集群中找到正确的节点
23. Kafka的服务协调者：Zookeeper
24. RocketMQ与Kafka如何实现事务
25. 物联网海量在线设备通信协议：MQTT

<h3 id="1">1. 为什么需要消息队列</h3>
哪些问题适合消息队列来解决

* 异步处理  
* 流量控制
* 服务解耦

其中流量控制最常见的有两种方式：<br>
一、在网关和后端服务之间加消息队列 <br>
App -> 网关 -> 消息队列 -> 秒杀服务 <br>
二、使用令牌桶 <br>
App -> 网关 -> 令牌队列 -> 秒杀服务 <br>
令牌桶 -> 生产 -> 令牌队列 <br>
网关在收到请求时，先去令牌队列中获取一个令牌，获取成功则继续调用秒杀服务，否则返回失败。<br>

<h3 id="2">2. 该如何选择消息队列</h3>
2.1 选择消息队列产品的基本标准

* 开源
* 近年来较流行的，有一定社区活跃度的
* 流行的产品与周边生态系统有一个较好的兼容 
* 产品本身一些机制：消息可靠传递，保证不丢消息、支持水平扩展（有集群模式）、高性能

2.2 比较几个比较流行的MQ产品

* RabbitMQ
<br>优点：轻量、迅捷、开箱即用。拥有灵活的路由配置（Exchange）
<br>缺点：性能和吞吐量一般为几万到十几万条每秒，Erlang语言开发，二次开发较难
* RocketMQ
<br>优点：性能好，每秒大约能处理几十万条消息、稳定可靠，特点响应快，中文社区活跃
<br>缺点：与国际一些生态产品兼容性略逊一筹
* Kafka
<br>优点：拥有强大的性能和吞吐量，流式计算大数据生态兼容性好
<br>缺点：由于“攒一波再处理”的特性，数据量小时反而延迟高

<h3 id="3">3. 主题和队列有什么区别</h3>
3.1 消息队列的发展演进

* 队列模型
<br>队列模型中的概念：
<br>生产者：生产消息的一方
<br>消费者：消费消息的一方
<br>队列：服务端存放消息的容器
<br>消息队列最初就是一个先进先出的线性表，这个线性表只允许在后端进行插入操作，在前端进行删除操作，并且在出队入队过程中保证严格有序。由于消息只能被删除一次，因此只能被消费一次，无法满足一份消息分发给多个消费者的场景，比如对于一份订单数据，支付系统、风控系统、分析系统都需要一份，这时就演化出了发布-订阅模型
* 发布订阅模型
<br>发布订阅模型中的概念：
<br>消息发布者：生产消息的一方
<br>订阅者：消费消息的一方
<br>主题：服务端存放消息的容器
<br>可以看出这和队列模型中的概念是相符的，发布者即生产者，订阅者即消费者，主题即队列。它们唯一的区别在于一份消息如何被消费多次的问题。下面我们就具体的说一说。

3.2 现有几个主流MQ的模型

* RabbitMQ
<br>RabbitMQ是少数依然使用队列模型的产品之一。那么它怎么解决多消费问题呢？
<br>首先RabbitMQ在生产者和队列之间有一个Exchange的路由交换机，生产者直接将消息发送到Exchange而不是队列中，而Exchange通过配置多个队列，发送多份完整的消息到队列，从而实现多消费的问题。虽然这种做法比较费劲，但好在RabbitMQ采用的是内存存储数据，因此性能也还可以。
* RocketMQ
<br>RocketMQ使用的模型是发布-订阅模型
<br>先来看看RocketMQ中几个重要的概念：
<br>发布者、订阅者、主题：这些和模型中的概念一模一样
<br>队列：此队列非“队列模型”中的“队列”。它的作用就是为了横向扩展。现在我们知道发布者将消息生产到服务端，也就是Broker，在Broker里用主题来存储消息，而一个主题包含多个队列。可以理解为发布者将消息发送到了这个主题的每个队列里，每个队列分管来自生产者的若干消息。其实将队列理解为分区更为贴切。一个主题被分成了若干个区域，每个区域存储一部分消息。而实际上Kafka就将队列叫做分区。
<br>有了队列（分区）就可以通过横向扩展增加队列和消费者的方式提高系统性能了，这也是为什么RocketMQ的数量级要远大于RabbitMQ的原因。
<br>但是你发现问题了没？消息发送给多个队列，那么如何保证消息的有序性？
<br>其实RocketMQ在主题层面不保证消息的有序性，它只在队列层面保证严格的队列顺序。那么要想发送有序消息就要考虑将消息发送到同一个队列中去。具体的做法可以参考apache rocketmq官网的例子https://rocketmq.apache.org/docs/order-example/
<br>在实际应用场景中，很多消息没必要保证有序性，这时我们就可以使用队列（分区）来做水平扩展了。
<br>那么每个队列如何保证消息的有序性呢？这得从消费确认机制说起。消息队列为了保证消息不丢以及消息的有序性，增加了请求-确认机制，在生产一端，生产者将消息发送给Broker后，只有接受到Broker返回的“成功确认“才能接着发送下一条消息，否则会重复发送该条消息，在消费一端，队列将消息发送给消费者后，也只有收到消费者的成功确认才能发下一条，否则也会重复发送。这个机制就很好的保证了消息传递的可靠性和有序性。
<br>消费组：RocketMQ中订阅者是通过消费组来体现的。每个消费组可以得到主题的一份完整的消息，不同消费组之间不受任何影响。每个消费组中包含多个消费者，同一组内的消费者是竞争的关系，比如一条消息被消费者1消费了，那么该组内其他消费者就不能再消费这条消息了。
<br>消费位置：一个队列可能对应多个消费组，那么如何标识队列中的某条消息有没有被消费过呢？为了记录这个信息，RocketMQ为每个消费组对应每个队列维护了一个位置变量，称为消费位置。有了消费位置，服务端就可以通过计算那些消息被全部消费过了，然后可以从队列中删除掉了。
<br>RocketMQ的结构图如下<br>
* Kafka
<br>Kafka的模型以及概念和RocketMQ的一模一样，只是把队列叫做分区，上面也已经说了。

<h3 id="4">4. 利用事务消息实现分布式事务</h3>
本节主要使用RocketMQ的事务消息来实现分布式事务。
<br>
<br><br>
<br>





